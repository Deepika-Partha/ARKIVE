//NOTE: These tests were originially generated by AI, given auth.js and a request for unit tests as a prompt.

import request from 'supertest';
import express, { json } from 'express';
import { hash, compare } from 'bcrypt';
import { sign } from 'jsonwebtoken';
import { create, findOne } from '../../models/User';
import authRouter from '../auth';

jest.mock('bcrypt');
jest.mock('jsonwebtoken');
jest.mock('../models/User');

const app = express();
app.use(json());
app.use('/api', authRouter);

const originalEnv = process.env;

describe('Auth Routes', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    process.env = { ...originalEnv };
  });

  afterAll(() => {
    process.env = originalEnv;
  });

  describe('POST /api/register', () => {
    const registerUrl = '/api/register';
    const validCredentials = { email: 'test@example.com', password: 'password123' };
    test('should register a new user successfully', async () => {
      hash.mockResolvedValue('hashedPassword123');
      create.mockResolvedValue({ _id: 'userId123', ...validCredentials, passwordHash: 'hashedPassword123' });
      const response = await request(app)
        .post(registerUrl)
        .send(validCredentials);
      expect(hash).toHaveBeenCalledWith(validCredentials.password, 10);
      expect(create).toHaveBeenCalledWith({ email: validCredentials.email, passwordHash: 'hashedPassword123' });
      expect(response.status).toBe(201);
      expect(response.body).toEqual({ message: 'Registration successful' });
    });

    test('should return 400 if email is missing', async () => {
      const response = await request(app)
        .post(registerUrl)
        .send({ password: 'password123' });
      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Email and password required' });
    });

    test('should return 400 if password is missing', async () => {
      const response = await request(app)
        .post(registerUrl)
        .send({ email: 'test@example.com' });
      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Email and password required' });
    });

    test('should return 400 for invalid email format', async () => {
      const response = await request(app)
        .post(registerUrl)
        .send({ email: 'invalidemail', password: 'password123' });
      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Invalid email format' });
    });

    test('should return 400 if password is less than 5 characters', async () => {
      const response = await request(app)
        .post(registerUrl)
        .send({ email: 'test@example.com', password: '1234' });
      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Password must be at least 5 characters long' });
    });

    test('should return 409 if email is already registered', async () => {
      create.mockRejectedValue({ code: 11000 });
      const response = await request(app)
        .post(registerUrl)
        .send(validCredentials);
      expect(response.status).toBe(409);
      expect(response.body).toEqual({ error: 'Email already registered' });
    });
  });

  describe('POST /api/login', () => {
    const loginUrl = '/api/login';
    const validCredentials = { email: 'test@example.com', password: 'password123' };
    const mockUser = {
      _id: 'userId123',
      email: validCredentials.email,
      passwordHash: 'hashedPassword123',
    };
    const mockToken = 'mockGeneratedToken';
    beforeEach(() => {
      process.env.JWT_SECRET = 'testsecret';
    });
    test('should login user successfully and set httpOnly cookie', async () => {
      findOne.mockResolvedValue(mockUser);
      compare.mockResolvedValue(true);
      sign.mockReturnValue(mockToken);
      const response = await request(app)
        .post(loginUrl)
        .send(validCredentials);
      expect(findOne).toHaveBeenCalledWith({ email: validCredentials.email });
      expect(compare).toHaveBeenCalledWith(validCredentials.password, mockUser.passwordHash);
      expect(sign).toHaveBeenCalledWith(
        { userId: mockUser._id, email: mockUser.email },
        'testsecret',
        { expiresIn: '1d' }
      );
      expect(response.status).toBe(200);
      expect(response.headers['set-cookie'][0]).toMatch(/token=mockGeneratedToken/);
      expect(response.headers['set-cookie'][0]).toMatch(/HttpOnly/);
      expect(response.headers['set-cookie'][0]).toMatch(/SameSite=Strict/);
      expect(response.headers['set-cookie'][0]).toMatch(/Max-Age=86400/); // 24 * 60 * 60 * 1000 / 1000
      expect(response.body).toEqual({ message: 'Login successful' });
    });
    test('should set secure cookie if NODE_ENV is production', async () => {
      process.env.NODE_ENV = 'production';
      findOne.mockResolvedValue(mockUser);
      compare.mockResolvedValue(true);
      sign.mockReturnValue(mockToken);
      const response = await request(app)
        .post(loginUrl)
        .send(validCredentials);
      expect(response.headers['set-cookie'][0]).toMatch(/Secure/);
    });
     test('should NOT set secure cookie if NODE_ENV is not production', async () => {
      process.env.NODE_ENV = 'development';
      findOne.mockResolvedValue(mockUser);
      compare.mockResolvedValue(true);
      sign.mockReturnValue(mockToken);
      const response = await request(app)
        .post(loginUrl)
        .send(validCredentials);
      expect(response.headers['set-cookie'][0]).not.toMatch(/Secure/);
    });

    test('should return 400 if user not found', async () => {
      findOne.mockResolvedValue(null);
      const response = await request(app)
        .post(loginUrl)
        .send(validCredentials);
      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Invalid email or password' });
    });

    test('should return 400 if password does not match', async () => {
      findOne.mockResolvedValue(mockUser);
      compare.mockResolvedValue(false);
      const response = await request(app)
        .post(loginUrl)
        .send(validCredentials);
      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Invalid email or password' });
    });

     test('should return 400 if email is not provided (implicitly)', async () => {
      findOne.mockResolvedValue(null);
      const response = await request(app)
        .post(loginUrl)
        .send({ password: 'password123' });
      expect(findOne).toHaveBeenCalledWith({ email: undefined });
      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Invalid email or password' });
    });

     test('should return 400 if password is not provided (implicitly)', async () => {
      findOne.mockResolvedValue(mockUser);
      compare.mockResolvedValue(false);
      const response = await request(app)
        .post(loginUrl)
        .send({ email: 'test@example.com' });
      expect(findOne).toHaveBeenCalledWith({ email: validCredentials.email });
      expect(compare).toHaveBeenCalledWith(undefined, mockUser.passwordHash);
      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Invalid email or password' });
    });
  });

  describe('POST /api/logout', () => {
    const logoutUrl = '/api/logout';
    test('should clear cookie and return success message', async () => {
      const response = await request(app)
        .post(logoutUrl)
        .send();
      expect(response.status).toBe(200);
      expect(response.headers['set-cookie'][0]).toMatch(/token=;/);
      expect(response.headers['set-cookie'][0]).toMatch(/Max-Age=0/);
      expect(response.body).toEqual({ message: 'Logged out' });
    });
  });
});