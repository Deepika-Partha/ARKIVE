'use strict';

var child_process = require('child_process');
var path = require('path');
var url = require('url');
var SvelteCompiler = require('svelte/compiler');
var fs = require('fs');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var SvelteCompiler__namespace = /*#__PURE__*/_interopNamespaceDefault(SvelteCompiler);

const configFilenames = ['svelte.config.js', 'svelte.config.cjs'];

function getSvelteConfig (rootMode, filename, preprocess) {
  let configFile = null;

  if (typeof preprocess === 'boolean') {
    configFile =
      rootMode === 'upward'
        ? findConfigFile(path.dirname(filename))
        : getConfigFile(process.cwd());
  } else if (typeof preprocess === 'string') {
    configFile = preprocess;
  }

  if (configFile === null || !fs.existsSync(configFile)) {
    throw Error(
      `Could not find ${configFilenames.join(' or ')} or ${configFile}.`
    )
  }

  return configFile
}

const getConfigFile = (searchDir) => {
  for (const configFilename of configFilenames) {
    const filePath = path.resolve(searchDir, configFilename);
    if (fs.existsSync(filePath)) {
      return filePath
    }
  }

  return null
};

const findConfigFile = (searchDir) => {
  const filePath = getConfigFile(searchDir);
  if (filePath !== null) {
    return filePath
  }

  const parentDir = path.resolve(searchDir, '..');
  return parentDir !== searchDir ? findConfigFile(parentDir) : null // Stop walking at filesystem root
};

const dynamicImport = async (filename) => import(url.pathToFileURL(filename).toString());

const IS_COMMON_JS = typeof module !== 'undefined';

const isSvelte3 = (version = SvelteCompiler__namespace.VERSION) => version.startsWith('3');

const DEFAULT_SVELTE_MODULE_INFIX = ['.svelte.'];

const DEFAULT_SVELTE_MODULE_EXT = ['.js', '.ts'];

const isSvelteModule = (filename) =>
  typeof SvelteCompiler__namespace.compileModule === 'function' &&
  DEFAULT_SVELTE_MODULE_INFIX.some((infix) => filename.includes(infix)) &&
  DEFAULT_SVELTE_MODULE_EXT.some((ext) => filename.endsWith(ext));

const currentFileExtension = (global.__dirname !== undefined ? path.extname(__filename) : path.extname(url.pathToFileURL((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (document.currentScript && document.currentScript.src || new URL('transformer.cjs', document.baseURI).href))).toString())).replace('.', '');

/**
 * Jest will only call this method when running in ESM mode.
 */
const processAsync = async (source, filename, jestOptions) => {
  const options = jestOptions && jestOptions.transformerConfig ? jestOptions.transformerConfig : {};
  const { preprocess, rootMode, debug } = options;

  if (IS_COMMON_JS) {
    throw new Error('Running svelte-jester-transformer async in unsupported CJS mode')
  }

  if (debug) {
    console.debug(`Running svelte-jester-transformer async in mode ${currentFileExtension}.`);
  }

  if (!preprocess) {
    return compiler('esm', options, filename, source)
  }

  const svelteConfigPath = getSvelteConfig(rootMode, filename, preprocess);
  const svelteConfig = await dynamicImport(svelteConfigPath);
  const processed = await SvelteCompiler__namespace.preprocess(
    source,
    svelteConfig.default.preprocess || {},
    { filename }
  );

  return compiler('esm', options, filename, processed.code, processed.map)
};

/**
 * Starts a new process, so it has a higher overhead than processAsync.
 * However, Jest calls this method in CJS mode.
 */
const processSync = (source, filename, jestOptions) => {
  const options = jestOptions && jestOptions.transformerConfig ? jestOptions.transformerConfig : {};
  const { preprocess, rootMode, maxBuffer, showConsoleLog, debug, svelteVersion } = options;

  if (!isSvelte3(svelteVersion)) {
    throw new Error('Jest is being called in CJS mode. You must use ESM mode in Svelte 4+')
  }

  if (!IS_COMMON_JS) {
    throw new Error('Running svelte-jester-transformer sync in unsupported ESM mode')
  }

  if (debug) {
    console.debug(`Running svelte-jester-transformer sync in mode ${currentFileExtension}.`);
  }

  if (!preprocess) {
    return compiler('cjs', options, filename, source)
  }

  const svelteConfig = getSvelteConfig(rootMode, filename, preprocess);
  const preprocessor = require.resolve('./preprocess.js');

  const preprocessResult = child_process.execSync(
        `node --unhandled-rejections=strict --abort-on-uncaught-exception "${preprocessor}"`,
        {
          env: { ...process.env, source, filename, svelteConfig, showConsoleLog },
          maxBuffer: maxBuffer || 10 * 1024 * 1024
        }
  ).toString();

  const parsedPreprocessResult = JSON.parse(preprocessResult);
  return compiler('cjs', options, filename, parsedPreprocessResult.code, parsedPreprocessResult.map)
};

const compiler = (format, options = {}, filename, processedCode, processedMap) => {
  const opts = {
    filename: path.basename(filename),
    css: isSvelte3(options.svelteVersion) ? true : 'injected',
    accessors: true,
    dev: true,
    sourcemap: processedMap,
    ...options.compilerOptions
  };

  if (isSvelte3(options.svelteVersion)) {
    opts.format = format;
  }

  const compile = isSvelteModule(filename) ? compileModule : compileComponent;

  let result;
  try {
    result = compile(processedCode, opts);
  } catch (error) {
    let msg = error.message;
    if (error.frame) {
      msg += '\n' + error.frame;
    }
    console.error(msg);
    throw error
  }

  if (options.debug) {
    console.log(result.js.code);
  }

  const esInterop = format === 'cjs' ? 'Object.defineProperty(exports, "__esModule", { value: true });' : '';

  return {
    code: result.js.code + esInterop,
    map: JSON.stringify(result.js.map)
  }
};

const compileComponent = (processedCode, opts) => {
  return SvelteCompiler__namespace.compile(processedCode, opts)
};

const compileModule = (processedCode, opts) => {
  return SvelteCompiler__namespace.compileModule(processedCode, {
    filename: opts.filename,
    dev: opts.dev,
    generate: opts.ssr ? 'server' : 'client'
  })
};

var transformer = {
  process: processSync,
  processAsync
};

module.exports = transformer;
